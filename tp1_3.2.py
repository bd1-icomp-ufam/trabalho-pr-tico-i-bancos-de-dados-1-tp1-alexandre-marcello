import configparser
import psycopg2
from psycopg2 import sql
import re
from datetime import datetime

# Função para conectar ao PostgreSQL
def connect_to_database(dbname):
    try:
        conexao = psycopg2.connect(
            host='localhost',
            database=dbname,
            user='postgres',
            password='1234',
            port='5432'
        )
        print(f"Conectado ao banco '{dbname}' com sucesso!")
        return conexao
    except Exception as e:
        print(f"Erro ao conectar ao banco de dados: {e}")
        return None


# Função para criar um banco de dados
def create_database(conexao, novo_banco):
    try:
        conexao.autocommit = True
        cursor = conexao.cursor()

        # Criar o banco de dados
        cursor.execute(sql.SQL("CREATE DATABASE {}").format(
            sql.Identifier(novo_banco)))
        print(f"Banco de dados '{novo_banco}' criado com sucesso!")
    except Exception as e:
        print(f"Erro ao criar o banco de dados: {e}")
    finally:
        cursor.close()

# Função para criar tabelas
def create_tables(conexao):
    try:
        cursor = conexao.cursor()

        comandos_sql = [
        """
        CREATE TABLE Grupo (
                id_grp INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                grp VARCHAR(20) UNIQUE NOT NULL
        );
        """,
        """
        CREATE TABLE Produto (
                asin VARCHAR(15) PRIMARY KEY,
                title VARCHAR(300),
                grp VARCHAR(20),
                salesrank INTEGER,
                avg_rating REAL,
                FOREIGN KEY (grp)
                        REFERENCES Grupo (grp) ON UPDATE CASCADE
                    
        );
        """,
        """
        CREATE TABLE Similare (
                asin_product VARCHAR(15),
                asin_similar VARCHAR(15),
                PRIMARY KEY (asin_product, asin_similar),
                FOREIGN KEY (asin_product)
                        REFERENCES Produto (asin) ON UPDATE CASCADE
        );
        """,
        """
        CREATE TABLE Categoria (
                id_cat INTEGER PRIMARY KEY,
                description VARCHAR(100)
        );
        """,
        """
        CREATE TABLE Produto_categoria (
                asin VARCHAR(15),
                id_cat INTEGER,
                PRIMARY KEY (asin, id_cat),
                FOREIGN KEY (asin)
                        REFERENCES Produto (asin) ON UPDATE CASCADE, 
                FOREIGN KEY (id_cat)
                        REFERENCES Categoria (id_cat) ON UPDATE CASCADE
        );
        """,
        """
        CREATE TABLE Cliente (
                customer VARCHAR(15) PRIMARY KEY
        );
        """,
        """
        CREATE TABLE Review (
                asin VARCHAR(15),
                customer VARCHAR(15),
                dt DATE,
                rating INTEGER,
                votes INTEGER,
                helpful INTEGER, 
                PRIMARY KEY (asin, customer, dt),
                FOREIGN KEY (asin) 
                        REFERENCES Produto (asin) ON UPDATE CASCADE,
                FOREIGN KEY (customer)
                        REFERENCES Cliente (customer) ON UPDATE CASCADE
        );
        """
        ]
    
        for comando in comandos_sql:
            cursor.execute(comando)
        print("Tabelas criadas com sucesso!")
    
    except Exception as e:
        print(f"Erro ao criar tabelas: {e}")
    
    finally:
        cursor.close()


# Abaixo as funções para inserção de dados nas tabelas
def inserir_grupo(conexao,grp):
    cursor = conexao.cursor()
    cursor.execute("INSERT INTO Grupo (grp) VALUES (%s) ON CONFLICT (grp) DO NOTHING;", (grp,))
    cursor.close()

def inserir_produto(conexao, asin, title, grp, salesrank):
    cursor = conexao.cursor()
    cursor.execute("""
    INSERT INTO Produto (asin, title, grp, salesrank)
    VALUES (%s, %s, %s, %s)
    ON CONFLICT (asin) DO NOTHING;""", (asin, title, grp, salesrank))
    cursor.close()

def inserir_avg_rating(conexao, avg_rating, asin):
    cursor = conexao.cursor()
    cursor.execute("""
    UPDATE Produto
    SET avg_rating = %s
    WHERE asin = %s;""", (avg_rating,asin))
    cursor.close()

def inserir_similar(conexao, asin_product, asin_similar):
    cursor = conexao.cursor()
    cursor.execute("""
    INSERT INTO Similare (asin_product, asin_similar)
    VALUES (%s, %s)
    ON CONFLICT (asin_product, asin_similar) DO NOTHING;""", (asin_product, asin_similar))
    cursor.close()

def inserir_categoria(conexao, id_cat, description):
    cursor = conexao.cursor()
    cursor.execute("""
    INSERT INTO Categoria (id_cat, description)
    VALUES (%s, %s)
    ON CONFLICT (id_cat) DO NOTHING;""", (id_cat, description))
    cursor.close()

def inserir_produto_categoria(conexao, asin, id_cat):
    cursor = conexao.cursor()
    cursor.execute("""
    INSERT INTO Produto_categoria (asin, id_cat)
    VALUES (%s, %s)
    ON CONFLICT (asin, id_cat) DO NOTHING;""", (asin, id_cat))
    cursor.close()

def inserir_cliente(conexao, customer):
    cursor = conexao.cursor()
    cursor.execute("INSERT INTO Cliente (customer) VALUES (%s) ON CONFLICT (customer) DO NOTHING;", (customer,))
    cursor.close()

def inserir_review(conexao, asin, customer, data, rating, votes, helpful):
    cursor = conexao.cursor()
    cursor.execute("""
    INSERT INTO Review (asin, customer, dt, rating, votes, helpful)
    VALUES (%s, %s, %s, %s, %s, %s)
    ON CONFLICT (asin, customer, dt) DO NOTHING;""", (asin, customer, data, rating, votes, helpful))
    cursor.close()

# Função para extrair categorias como tuplas de (id_cat, description)
def extrair_categorias(linha):
    # Expressão regular para capturar o texto à esquerda e o número entre colchetes
    pattern = r'([^\[\|]+)\[(\d+)\]'
    # Encontrar todas as ocorrências e retornar como uma lista de tuplas (description, id_cat)
    categorias = re.findall(pattern, linha)
    # Inverter para obter na ordem (id_cat, description)
    return [(int(id_cat), description.strip()) for description, id_cat in categorias]

# Função de povoamento das tabelas
def povoar_tabelas(conexao,arquivo_dados):
    with open(arquivo_dados, 'r', encoding='utf-8') as arquivo:
        asin, title, grp, salesrank, avg_rating = None, None, None, None, None
        similares = []
        categorias = []
        
        for linha in arquivo:
            linha = linha.strip()

            if linha.startswith("ASIN:"):
                asin = linha.split(":")[1].strip()
            
            elif linha.startswith("title:"):
                title = linha.split(":")[1].strip()
            
            elif linha.startswith("group:"):
                grp = linha.split(":")[1].strip()
                inserir_grupo(conexao, grp)  # Inserir o grupo
            
            elif linha.startswith("salesrank:"):
                salesrank = int(linha.split(":")[1].strip())
                inserir_produto(conexao, asin, title, grp, salesrank)  # Inserir o produto
            
            elif linha.startswith("similar:"):
                similares = linha.split()[2:]  # Obtem as ASINs similares
                for similar in similares:
                    inserir_similar(conexao, asin, similar)  # Inserir produtos similares
            
            elif linha.strip().startswith("|"):
                # Extrair categorias como uma lista de tuplas (id_cat, description)
                categorias = extrair_categorias(linha)
                
                inserir_categoria(conexao, categorias[-1][0], categorias[-1][1])  # Inserir a categoria
                inserir_produto_categoria(conexao,asin, categorias[-1][0])  # Inserir produto-categoria
            
            elif linha.startswith("reviews:"):
                avg_rating = float(linha.split()[7].strip())
                inserir_avg_rating(conexao, avg_rating, asin)  # Inserir avg_rating na tabela do produto
                
            elif re.match(r"\d{4}-\d{1,2}-\d{1,2}", linha):  # Linha de review
                #Conversão da data para formato aceito para inserção no BD
                data_str = linha.split()[0]
                partes = data_str.split('-')
                ano=partes[0]
                mes=partes[1].zfill(2)
                dia=partes[2].zfill(2)
                data=f"{ano}-{mes}-{dia}"
                formato = "%Y-%m-%d"
                data_obj = datetime.strptime(data, formato).date()
                
                customer = linha.split()[2]
                rating = linha.split()[4]
                votes = linha.split()[6]
                helpful = linha.split()[8]
                
                inserir_cliente(conexao, customer)
                inserir_review(conexao, asin, customer, data_obj, int(rating), int(votes), int(helpful))
    
    # Confirmar inserções no banco de dados
    conexao.commit()


if __name__ == '__main__':
    # Conectar ao banco padrão para criar o novo banco de dados
    conexao = connect_to_database('postgres')
    
    novo_banco = "produtosAmazon_BD_alexandre_marcello"
    
    if conexao:
        #Criar novo banco de dados
        create_database(conexao, novo_banco)
        conexao.close()

        # Conectar ao novo banco de dados
        conexao = connect_to_database(novo_banco)
        
        if conexao:
        
            create_tables(conexao) #criar tabelas
            arquivo_dados = 'amazon-meta.txt'  # Caminho para o arquivo de dados
            print("Povoando as tabelas. Aguarde, por favor. O processo pode demorar alguns minutos...")
        
            povoar_tabelas(conexao, arquivo_dados) 
            print("Povoamento das tabelas finalizado. Obrigado por aguardar.")
        
            conexao.close()
